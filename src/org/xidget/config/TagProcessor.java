/**
 * Xidget - UI Toolkit based on XModel
 * Copyright 2009 Bob Dunnagan. All rights reserved.
 */
package org.xidget.config;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Stack;
import org.xidget.IFeatured;
import org.xidget.Log;
import org.xmodel.IModelObject;
import org.xmodel.Xlate;
import org.xmodel.util.HashMultiMap;
import org.xmodel.util.MultiMap;
import org.xmodel.xpath.expression.IContext;
import org.xmodel.xpath.expression.IExpression;
import org.xmodel.xpath.expression.StatefulContext;

/**
 * A class which processes an xml fragment using a set of handlers registered by element name.
 */
public class TagProcessor implements IFeatured
{
  /**
   * Create a root tag processor.
   */
  public TagProcessor()
  {
    this( null);
  }
  
  /**
   * Create a tag processor which operates in a subtree of the specified handler.
   * @param parent The parent handler.
   */
  public TagProcessor( ITagHandler parent)
  {
    this.loader = getClass().getClassLoader();
    this.parent = parent;
    this.elementHandlers = new HashMultiMap<String, ITagHandler>();
    this.attributeHandlers = new HashMultiMap<String, ITagHandler>();
    this.roots = new ArrayList<Object>();
  }
  
  /**
   * Set the ClassLoader associated with this tag processor for use by tag handlers
   * which need to dynamic load classes.
   * @param loader The loader.
   */
  public void setClassLoader( ClassLoader loader)
  {
    this.loader = loader;
  }
  
  /**
   * Returns the ClassLoader associated with this processor.
   * @return Returns the ClassLoader associated with this processor.
   */
  public ClassLoader getClassLoader()
  {
    return loader;
  }
  
  /**
   * Returns null or the parent handler.
   * @return Returns null or the parent handler.
   */
  public ITagHandler getParent()
  {
    return parent;
  }
  
  /**
   * Called by root tag handlers.
   * @param object The root object generated by a root tag handler.
   */
  public void addRoot( Object object)
  {
    roots.add( object);
  }

  /**
   * Returns the objects emitted by the root tag handlers.
   * @return Returns the objects emitted by the root tag handles.
   */
  public List<Object> getRoots()
  {
    return roots;
  }
  
  /**
   * Returns the context with which the process method was invoked.
   * @return Returns the context with which the process method was invoked.
   */
  public IContext getContext()
  {
    return context;
  }
  
  /**
   * Process the specified fragment and return the objects emitted by the root tag handlers.
   * @param context The root of the fragment to be processed.
   * @return Returns the objects emitted by root tag handlers.
   */
  public List<Object> process( IContext context) throws TagException
  {
    roots.clear();
    process( null, context);
    return roots;
  }
  
  /**
   * Process the specified fragment specifying the initial parent handler.
   * @param parent The parent handler of the root.
   * @param context The root of the fragment.
   */
  public void process( ITagHandler parent, IContext context) throws TagException
  {
    long t0 = System.nanoTime();
    
    this.context = context;
    
    Stack<Entry> stack = new Stack<Entry>();
    stack.push( new Entry( parent, null, context.getObject(), false));
    
    while( !stack.empty())
    {
      Entry entry = stack.pop();
     
      // check for exit entry
      if ( entry.end)
      {
        entry.handler.exit( this, entry.parent, entry.node);
        continue;
      }
      
      // process tag
      if ( entry.attribute) processAttributeHandlers( stack, entry);
      else processElementHandlers( stack, entry);
    }
    
    long t1 = System.nanoTime();
    Log.printf( "perf", "TagProcessor.process: time=%3.3fms\n", ((t1-t0)/1000000f));
  }

  /**
   * Process the attribute tag handlers for the specified entry.
   * @param stack The stack.
   * @param entry The attribute entry.
   */
  private void processAttributeHandlers( Stack<Entry> stack, Entry entry) throws TagException
  {
    List<ITagHandler> handlers = attributeHandlers.get( entry.node.getType());
    if ( handlers != null)
    {
      for( ITagHandler handler: handlers)
      {
        if ( handler.filter( this, entry.parent, entry.node))
        {
          handler.enter( this, entry.parent, entry.node);
          handler.exit( this, entry.parent, entry.node);
        }
      }
    }
  }
  
  /**
   * Process the element tag handlers for the specified entry.
   * @param stack The stack.
   * @param entry The element entry.
   */
  private void processElementHandlers( Stack<Entry> stack, Entry entry) throws TagException
  {
    // replace insert elements
    replaceInserts( entry.node);
    
    // process handlers
    List<ITagHandler> handlers = getHandlers( entry.node);
    if ( handlers == null)
    {        
      // push attributes for unhandled tags
      List<IModelObject> attributes = getAttributes( entry.node);
      for( int i=attributes.size()-1; i>=0; i--)
      {
        stack.add( new Entry( entry.parent, null, attributes.get( i), true, false));
      }        
      
      // push children for unhandled tags
      List<IModelObject> children = entry.node.getChildren();
      for( int i=children.size()-1; i>=0; i--)
      {
        stack.add( new Entry( entry.parent, null, children.get( i), false));
      }        
    }
    else if ( handlers.size() == 1)
    {
      ITagHandler handler = handlers.get( 0);
      if ( handler.filter( this, entry.parent, entry.node))
      {
        if ( handler.enter( this, entry.parent, entry.node))
        {
          List<IModelObject> children = entry.node.getChildren();
          
          // push special exit entry
          stack.push( new Entry( entry.parent, handler, entry.node, true));
          
          // push attributes for unhandled tags
          List<IModelObject> attributes = getAttributes( entry.node);
          for( int i=attributes.size()-1; i>=0; i--)
          {
            stack.add( new Entry( handler, null, attributes.get( i), true, false));
          }        
          
          // push children
          for( int i=children.size()-1; i>=0; i--)
          {
            stack.add( new Entry( handler, null, children.get( i), false));
          }
        }
      }
    }
    else if ( handlers.size() > 1)
    {
      List<ITagHandler> list = process( handlers, entry);
      List<IModelObject> children = entry.node.getChildren();
      for( ITagHandler handler: list)
      {
        // push special exit entry
        stack.push( new Entry( entry.parent, handler, entry.node, true));
        
        // push attributes for unhandled tags
        List<IModelObject> attributes = getAttributes( entry.node);
        for( int i=attributes.size()-1; i>=0; i--)
        {
          stack.add( new Entry( handler, null, attributes.get( i), true, false));
        }        
        
        // push children
        for( int i=children.size()-1; i>=0; i--)
        {
          stack.add( new Entry( handler, null, children.get( i), false));
        }
      }
    }
  }

  /**
   * Recursively replace insert elements among the children of the specified parent.
   * @param parent The parent.
   */
  private void replaceInserts( IModelObject parent) throws TagException
  {
    List<IModelObject> children = new ArrayList<IModelObject>( parent.getChildren());
    int insert=1;
    for( int i=0; i<children.size(); i++, insert++)
    {
      IModelObject child = children.get( i);
      if ( child.isType( "insert"))
      {
        IExpression targetExpr = Xlate.get( child, (IExpression)null);
        if ( targetExpr == null) throw new TagException( "Error in insert expression: "+child.getValue());
        
        // get targets
        List<IModelObject> targets = targetExpr.query( new StatefulContext( context, child), null);
        
        // remove insert element
        child.removeFromParent();
        insert--;
        
        // insert targets at index
        for( IModelObject target: targets)
        {
          // recursion
          replaceInserts( target);
          
          // insert
          parent.addChild( target.cloneTree(), insert++);
        }
      }
    }
  }
  
  /**
   * Returns the tag handlers for the specified element.
   * @param element The element.
   * @return Returns the tag handlers for the specified element.
   */
  private List<ITagHandler> getHandlers( IModelObject element)
  {
    List<ITagHandler> globals = elementHandlers.get( null);
    List<ITagHandler> tagged = elementHandlers.get( element.getType());
    if ( globals == null) return tagged;
    if ( tagged == null) return globals;
    
    List<ITagHandler> handlers = new ArrayList<ITagHandler>();
    handlers.addAll( globals);
    handlers.addAll( elementHandlers.get( element.getType()));
    return handlers;
  }
  
  /**
   * Process tag with multiple handlers.
   * @param handlers A list containing more than one handler.
   * @param entry The entry to be processed.
   * @return Returns the list of handlers that requested child processing.
   */
  private List<ITagHandler> process( List<ITagHandler> handlers, Entry entry) throws TagException
  {
    List<ITagHandler> list = new ArrayList<ITagHandler>();
    for( int i=handlers.size()-1; i>=0; i--)
    {
      ITagHandler handler = handlers.get( i);
      if ( handler.filter( this, entry.parent, entry.node))
      {
        if ( handler.enter( this, entry.parent, entry.node))
        {
          list.add( handler);
        }
      }
    }
    return list;
  }
  
  /**
   * Returns the attributes of the specified element.
   * @param element The element. 
   * @return Returns the attributes of the specified element.
   */
  private List<IModelObject> getAttributes( IModelObject element)
  {
    List<IModelObject> nodes = new ArrayList<IModelObject>();
    for( String attribute: element.getAttributeNames())
      nodes.add( element.getAttributeNode( attribute));
    return nodes;
  }
  
  /**
   * Add a tag handler which will be tested against every node.
   * @param handler The handler.
   */
  public void addHandler( ITagHandler handler)
  {
    addHandler( null, handler);
  }
  
  /**
   * Remove a tag handler which is tested against every node.
   * @param handler The handler.
   */
  public void removeHandler( ITagHandler handler)
  {
    removeHandler( null, handler);
  }
  
  /**
   * Add a tag handler. More than one handler can be registered for a particular
   * element name. In this case the handler <code>filter</code> method will be
   * called to disambiguate.
   * @param tag The tag.
   * @param handler The handler.
   */
  public void addHandler( String tag, ITagHandler handler)
  {
    elementHandlers.put( tag, handler);
  }
  
  /**
   * Remove a tag handler.
   * @param tag The tag.
   * @param handler The handler.
   */
  public void removeHandler( String tag, ITagHandler handler)
  {
    elementHandlers.remove( tag, handler);
  }
  
  /**
   * Replaces the first handler with the specified tag. If the tag does not have a handler, it is added.
   * @param tag The tag.
   * @param handler The replacement handler.
   */
  public void replaceHandler( String tag, ITagHandler handler)
  {
    List<ITagHandler> handlers = getHandlers( tag);
    if ( handlers.size() > 0) removeHandler( tag, handlers.get( 0));
    addHandler( tag, handler);
  }
  
  /**
   * Returns the handlers for the specified tag.
   * @param tag The tag.
   * @return Returns the handlers for the specified tag.
   */
  public List<ITagHandler> getHandlers( String tag)
  {
    return elementHandlers.get( tag);
  }
  
  /**
   * Add a tag handler. More than one handler can be registered for a particular
   * element name. In this case the handler <code>filter</code> method will be
   * called to disambiguate.
   * @param tag The tag.
   * @param handler The handler.
   */
  public void addAttributeHandler( String tag, ITagHandler handler)
  {
    attributeHandlers.put( tag, handler);
  }
  
  /**
   * Remove a tag handler.
   * @param tag The tag.
   * @param handler The handler.
   */
  public void removeAttibuteHandler( String tag, ITagHandler handler)
  {
    attributeHandlers.remove( tag, handler);
  }
  
  /**
   * Returns the handlers for the specified tag.
   * @param tag The tag.
   * @return Returns the handlers for the specified tag.
   */
  public List<ITagHandler> getAttibuteHandlers( String tag)
  {
    return attributeHandlers.get( tag);
  }
    
  /* (non-Javadoc)
   * @see org.xidget.IFeatures#setFeature(java.lang.Object)
   */
  public void setFeature( Class<? extends Object> featureClass, Object feature)
  {
    if ( features == null) features = new HashMap<Class<? extends Object>, Object>();
    features.put( featureClass, feature);
  }

  /* (non-Javadoc)
   * @see org.xidget.IFeatured#getFeature(java.lang.Class)
   */
  @SuppressWarnings("unchecked")
  public <T> T getFeature( Class<T> clss)
  {
    if ( features == null) return null;
    return (T)features.get( clss);
  }

  /**
   * An entry in the tag processing fifo used to keep track of parentage.
   */
  private class Entry
  {
    public Entry( ITagHandler parent, ITagHandler handler, IModelObject element, boolean end)
    {
      this.parent = parent;
      this.handler = handler;
      this.node = element;
      this.attribute = false;
      this.end = end;
    }
    
    public Entry( ITagHandler parent, ITagHandler handler, IModelObject node, boolean attribute, boolean end)
    {
      this.parent = parent;
      this.handler = handler;
      this.node = node;
      this.attribute = attribute;
      this.end = end;
    }
    
    public ITagHandler parent;
    public ITagHandler handler;
    public IModelObject node;
    public boolean attribute;
    public boolean end;
  }
 
  private IContext context;
  private ITagHandler parent;
  private ClassLoader loader;
  private MultiMap<String, ITagHandler> elementHandlers;
  private MultiMap<String, ITagHandler> attributeHandlers;
  private List<Object> roots;
  private Map<Class<? extends Object>, Object> features;
}